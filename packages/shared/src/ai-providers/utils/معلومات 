ğŸ“ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ØªÙƒØ§Ù…Ù„
text
packages/shared/src/ai-providers/ (Ø§Ø³ØªÙƒÙ…Ø§Ù„)
â”œâ”€â”€ router/
â”‚   â”œâ”€â”€ intelligent-router.ts         # Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø§Ù„Ø°ÙƒÙŠ Ø§Ù„ÙƒØ§Ù…Ù„
â”‚   â”œâ”€â”€ provider-selector.ts          # Ù…Ø­Ø¯Ø¯ Ø§Ù„Ù…Ø²ÙˆØ¯ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
â”‚   â”œâ”€â”€ fallback-manager.ts           # Ù…Ø¯ÙŠØ± Fallback Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„
â”‚   â””â”€â”€ cost-optimizer.ts             # Ù…Ø­Ø³Ù† Ø§Ù„ØªÙƒÙ„ÙØ©
â”œâ”€â”€ monitoring/
â”‚   â”œâ”€â”€ provider-monitor.ts           # Ù…Ø±Ø§Ù‚Ø¨ Ø§Ù„Ø£Ø¯Ø§Ø¡
â”‚   â”œâ”€â”€ cost-tracker.ts               # Ù…ØªØªØ¨Ø¹ Ø§Ù„ØªÙƒÙ„ÙØ©
â”‚   â””â”€â”€ metrics-collector.ts          # Ø¬Ø§Ù…Ø¹ Ø§Ù„Ù…Ù‚Ø§ÙŠÙŠØ³
â””â”€â”€ integration/                      # Ø§Ù„ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ
    â”œâ”€â”€ agent-loop-integration.ts     # ØªÙƒØ§Ù…Ù„ Agent Loop
    â”œâ”€â”€ tool-execution-integration.ts # ØªÙƒØ§Ù…Ù„ ØªÙ†ÙÙŠØ° Ø§Ù„Ø£Ø¯ÙˆØ§Øª
    â””â”€â”€ cli-integration.ts            # ØªÙƒØ§Ù…Ù„ CLI
ğŸš€ ØªÙ†ÙÙŠØ° Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø§Ù„Ø°ÙƒÙŠ ÙˆØ§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
1. Ø§Ù„Ù…ÙˆØ¬Ù‡ Ø§Ù„Ø°ÙƒÙŠ (Intelligent Router)
router/intelligent-router.ts

typescript
import { ProviderRegistry } from '../registry/provider-registry';
import { ProviderSelector } from './provider-selector';
import { FallbackManager } from './fallback-manager';
import { CostOptimizer } from './cost-optimizer';
import { IAIProvider, UnifiedMessage, UnifiedTool, UnifiedResponse } from '../interfaces';

export class IntelligentRouter {
  private registry: ProviderRegistry;
  private selector: ProviderSelector;
  private fallbackManager: FallbackManager;
  private costOptimizer: CostOptimizer;
  private defaultProvider: string = 'claude';

  constructor(registry: ProviderRegistry) {
    this.registry = registry;
    this.selector = new ProviderSelector(registry);
    this.fallbackManager = new FallbackManager(registry);
    this.costOptimizer = new CostOptimizer(registry);
  }

  /**
   * Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø°ÙƒÙŠØ© Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø²ÙˆØ¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
   */
  async chat(
    messages: UnifiedMessage[], 
    options: RouterOptions = {}
  ): Promise<UnifiedResponse> {
    const taskAnalysis = this.analyzeTask(messages, options);
    const selectedProvider = await this.selector.selectProvider(taskAnalysis);
    
    return this.fallbackManager.executeWithFallback(
      selectedProvider,
      (provider: IAIProvider) => provider.chat(messages),
      taskAnalysis
    );
  }

  /**
   * Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ù…Ø¹ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø²ÙˆØ¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
   */
  async chatWithTools(
    messages: UnifiedMessage[],
    tools: UnifiedTool[],
    options: RouterOptions = {}
  ): Promise<UnifiedResponse> {
    const taskAnalysis = this.analyzeTask(messages, { ...options, tools });
    const selectedProvider = await this.selector.selectProvider(taskAnalysis);
    
    return this.fallbackManager.executeWithFallback(
      selectedProvider,
      (provider: IAIProvider) => provider.chatWithTools(messages, tools),
      taskAnalysis
    );
  }

  /**
   * Ø§Ø®ØªÙŠØ§Ø± Ù…Ø²ÙˆØ¯ Ù…Ø­Ø¯Ø¯ ÙŠØ¯ÙˆÙŠØ§Ù‹ (Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…)
   */
  async withProvider(
    providerName: string,
    operation: (provider: IAIProvider) => Promise<UnifiedResponse>
  ): Promise<UnifiedResponse> {
    const provider = this.registry.getProvider(providerName);
    return this.fallbackManager.executeWithFallback(
      providerName,
      operation,
      { providerPreference: providerName }
    );
  }

  /**
   * ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ù‡Ù…Ø© Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª
   */
  private analyzeTask(messages: UnifiedMessage[], options: RouterOptions): TaskAnalysis {
    const lastMessage = messages[messages.length - 1]?.content || '';
    const hasTools = options.tools && options.tools.length > 0;
    
    return {
      // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†Øµ
      requiresTools: hasTools,
      complexity: this.estimateComplexity(lastMessage),
      estimatedTokens: this.estimateTokens(messages),
      
      // Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª
      budget: options.budget,
      speedPriority: options.speedPriority || false,
      qualityPriority: options.qualityPriority || false,
      
      // Ø§Ù„Ø³ÙŠØ§Ù‚
      providerPreference: options.providerPreference,
      fallbackEnabled: options.fallbackEnabled !== false
    };
  }

  private estimateComplexity(text: string): number {
    // ØªØ­Ù„ÙŠÙ„ Ø¨Ø³ÙŠØ· Ù„Ù„ØªØ¹Ù‚ÙŠØ¯ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø·ÙˆÙ„ Ø§Ù„Ù†Øµ ÙˆØ§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ©
    const lengthScore = Math.min(text.length / 1000, 1);
    const keywordScore = this.detectComplexityKeywords(text);
    return Math.min(lengthScore + keywordScore, 1);
  }

  private detectComplexityKeywords(text: string): number {
    const complexKeywords = ['Ù…Ø¹Ù‚Ø¯', 'ÙƒØ¨ÙŠØ±', 'Ù…Ø´Ø±ÙˆØ¹', 'Ù†Ø¸Ø§Ù…', 'enterprise', 'ÙƒØ§Ù…Ù„'];
    const matches = complexKeywords.filter(keyword => 
      text.toLowerCase().includes(keyword.toLowerCase())
    );
    return matches.length * 0.2;
  }

  private estimateTokens(messages: UnifiedMessage[]): number {
    return messages.reduce((total, msg) => total + (msg.metadata?.tokens || this.estimateTextTokens(msg.content)), 0);
  }

  private estimateTextTokens(text: string): number {
    return Math.ceil(text.length / 4); // ØªÙ‚Ø¯ÙŠØ± ØªÙ‚Ø±ÙŠØ¨ÙŠ
  }

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…
   */
  getRouterStats(): RouterStats {
    return {
      totalRequests: this.fallbackManager.getTotalRequests(),
      successRate: this.fallbackManager.getSuccessRate(),
      averageCost: this.costOptimizer.getAverageCost(),
      providerPerformance: this.selector.getProviderPerformance(),
      costSavings: this.costOptimizer.getCostSavings()
    };
  }
}

export interface RouterOptions {
  providerPreference?: string;
  budget?: number;
  speedPriority?: boolean;
  qualityPriority?: boolean;
  tools?: UnifiedTool[];
  fallbackEnabled?: boolean;
}

export interface TaskAnalysis {
  requiresTools: boolean;
  complexity: number;
  estimatedTokens: number;
  budget?: number;
  speedPriority: boolean;
  qualityPriority: boolean;
  providerPreference?: string;
  fallbackEnabled: boolean;
}

export interface RouterStats {
  totalRequests: number;
  successRate: number;
  averageCost: number;
  providerPerformance: Record<string, any>;
  costSavings: number;
}
2. Ù…Ø­Ø¯Ø¯ Ø§Ù„Ù…Ø²ÙˆØ¯ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… (Provider Selector)
router/provider-selector.ts

typescript
import { ProviderRegistry } from '../registry/provider-registry';
import { IAIProvider, ProviderCapabilities } from '../interfaces';

export class ProviderSelector {
  private registry: ProviderRegistry;
  private performanceHistory: Map<string, ProviderPerformance> = new Map();
  private selectionWeights = {
    cost: 0.4,
    capabilities: 0.3,
    performance: 0.2,
    availability: 0.1
  };

  constructor(registry: ProviderRegistry) {
    this.registry = registry;
    this.initializePerformanceTracking();
  }

  /**
   * Ø§Ø®ØªÙŠØ§Ø± Ø£ÙØ¶Ù„ Ù…Ø²ÙˆØ¯ Ù„Ù„Ù…Ù‡Ù…Ø©
   */
  async selectProvider(taskAnalysis: any): Promise<string> {
    const availableProviders = this.registry.getAvailableProviders();
    
    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ ØªÙØ¶ÙŠÙ„ Ù…Ø­Ø¯Ø¯
    if (taskAnalysis.providerPreference && availableProviders.includes(taskAnalysis.providerPreference)) {
      return taskAnalysis.providerPreference;
    }

    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø· Ù„ÙƒÙ„ Ù…Ø²ÙˆØ¯
    const providerScores = await Promise.all(
      availableProviders.map(async provider => ({
        provider,
        score: await this.calculateProviderScore(provider, taskAnalysis)
      }))
    );

    // Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø²ÙˆØ¯ Ø¨Ø£Ø¹Ù„Ù‰ Ù†Ù‚Ø§Ø·
    providerScores.sort((a, b) => b.score - a.score);
    return providerScores[0].provider;
  }

  /**
   * Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø· Ù„ÙƒÙ„ Ù…Ø²ÙˆØ¯
   */
  private async calculateProviderScore(providerName: string, taskAnalysis: any): Promise<number> {
    const provider = this.registry.getProvider(providerName);
    const capabilities = provider.getCapabilities();
    const performance = this.performanceHistory.get(providerName) || this.defaultPerformance();

    let score = 0;

    // 1. Ø§Ù„ØªÙƒÙ„ÙØ© (40%)
    score += this.calculateCostScore(provider, taskAnalysis) * this.selectionWeights.cost;

    // 2. Ø§Ù„Ù‚Ø¯Ø±Ø§Øª (30%)
    score += this.calculateCapabilitiesScore(capabilities, taskAnalysis) * this.selectionWeights.capabilities;

    // 3. Ø§Ù„Ø£Ø¯Ø§Ø¡ (20%)
    score += this.calculatePerformanceScore(performance) * this.selectionWeights.performance;

    // 4. Ø§Ù„ØªÙˆÙØ± (10%)
    score += this.calculateAvailabilityScore(performance) * this.selectionWeights.availability;

    return score;
  }

  private calculateCostScore(provider: IAIProvider, taskAnalysis: any): number {
    const pricing = provider.getPricing();
    const estimatedCost = (taskAnalysis.estimatedTokens * pricing.inputCostPerToken) + 
                         (1000 * pricing.outputCostPerToken); // ØªÙ‚Ø¯ÙŠØ± Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬
    
    // Ø£Ø±Ø®Øµ = Ù†Ù‚Ø§Ø· Ø£Ø¹Ù„Ù‰
    const maxAcceptableCost = taskAnalysis.budget || 0.1; // $0.1 Ø§ÙØªØ±Ø§Ø¶ÙŠ
    return Math.max(0, 1 - (estimatedCost / maxAcceptableCost));
  }

  private calculateCapabilitiesScore(capabilities: ProviderCapabilities, taskAnalysis: any): number {
    let score = 0.5; // Ø¯Ø±Ø¬Ø© Ø£Ø³Ø§Ø³ÙŠØ©

    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ù‡Ù…Ø© ØªØ­ØªØ§Ø¬ Ø£Ø¯ÙˆØ§Øª ÙˆØ§Ù„Ù…Ø²ÙˆØ¯ ÙŠØ¯Ø¹Ù…Ù‡Ø§
    if (taskAnalysis.requiresTools && capabilities.supportsTools) {
      score += 0.3;
    }

    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ù‡Ù…Ø© Ù…Ø¹Ù‚Ø¯Ø© ÙˆØ§Ù„Ù…Ø²ÙˆØ¯ Ù‚ÙˆÙŠ
    if (taskAnalysis.complexity > 0.7 && capabilities.maxTokens > 100000) {
      score += 0.2;
    }

    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ù„Ù„Ø¬ÙˆØ¯Ø© ÙˆØ§Ù„Ù…Ø²ÙˆØ¯ Ù…ØªÙ‚Ø¯Ù…
    if (taskAnalysis.qualityPriority && capabilities.availableModels.length > 2) {
      score += 0.2;
    }

    return Math.min(1, score);
  }

  private calculatePerformanceScore(performance: ProviderPerformance): number {
    // ÙˆÙ‚Øª Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø£ÙØ¶Ù„ = Ù†Ù‚Ø§Ø· Ø£Ø¹Ù„Ù‰
    const responseTimeScore = 1 - Math.min(performance.avgResponseTime / 10000, 1);
    const successRateScore = performance.successRate;
    
    return (responseTimeScore * 0.6) + (successRateScore * 0.4);
  }

  private calculateAvailabilityScore(performance: ProviderPerformance): number {
    // ØªÙˆÙØ± Ø£Ø¹Ù„Ù‰ = Ù†Ù‚Ø§Ø· Ø£Ø¹Ù„Ù‰
    return performance.availability;
  }

  /**
   * ØªØ­Ø¯ÙŠØ« Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ø²ÙˆØ¯ Ø¨Ø¹Ø¯ ÙƒÙ„ Ø·Ù„Ø¨
   */
  recordProviderResult(providerName: string, success: boolean, responseTime: number, cost: number): void {
    const performance = this.performanceHistory.get(providerName) || this.defaultPerformance();
    
    performance.totalRequests++;
    if (success) {
      performance.successfulRequests++;
    }
    
    // ØªØ­Ø¯ÙŠØ« Ù…ØªÙˆØ³Ø· ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
    performance.avgResponseTime = (
      (performance.avgResponseTime * (performance.totalRequests - 1)) + responseTime
    ) / performance.totalRequests;
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©
    performance.totalCost += cost;
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙˆÙØ±
    performance.availability = performance.successfulRequests / performance.totalRequests;
    
    this.performanceHistory.set(providerName, performance);
  }

  private defaultPerformance(): ProviderPerformance {
    return {
      totalRequests: 0,
      successfulRequests: 0,
      avgResponseTime: 0,
      totalCost: 0,
      availability: 1,
      successRate: 1
    };
  }

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡
   */
  getProviderPerformance(): Record<string, ProviderPerformance> {
    return Object.fromEntries(this.performanceHistory);
  }

  private initializePerformanceTracking(): void {
    const providers = this.registry.getAvailableProviders();
    providers.forEach(provider => {
      this.performanceHistory.set(provider, this.defaultPerformance());
    });
  }
}

interface ProviderPerformance {
  totalRequests: number;
  successfulRequests: number;
  avgResponseTime: number;
  totalCost: number;
  availability: number;
  successRate: number;
}
3. Ù…Ø¯ÙŠØ± Fallback Ø§Ù„Ù…ØªÙƒØ§Ù…Ù„
router/fallback-manager.ts

typescript
import { ProviderRegistry } from '../registry/provider-registry';
import { IAIProvider, UnifiedResponse } from '../interfaces';

export class FallbackManager {
  private registry: ProviderRegistry;
  private maxRetries = 3;
  private retryableErrors = [
    'timeout', 'network', 'rate_limit', 'overload', 'internal_error'
  ];

  constructor(registry: ProviderRegistry) {
    this.registry = registry;
  }

  /**
   * ØªÙ†ÙÙŠØ° Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù…Ø¹ Fallback ØªÙ„Ù‚Ø§Ø¦ÙŠ
   */
  async executeWithFallback(
    primaryProvider: string,
    operation: (provider: IAIProvider) => Promise<UnifiedResponse>,
    context: any = {}
  ): Promise<UnifiedResponse> {
    const providers = this.getFallbackOrder(primaryProvider, context);
    let lastError: Error;

    for (let i = 0; i < providers.length; i++) {
      const providerName = providers[i];
      
      try {
        const provider = this.registry.getProvider(providerName);
        const result = await this.executeWithRetry(provider, operation, i + 1);
        
        console.log(`âœ… Success with provider: ${providerName}`);
        return result;
        
      } catch (error: any) {
        console.log(`âŒ Provider ${providerName} failed: ${error.message}`);
        lastError = error;
        
        // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø§Ù„Ø®Ø·Ø£ Ù‚Ø§Ø¨Ù„Ø§Ù‹ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©ØŒ ØªÙˆÙ‚Ù
        if (!this.isRetryableError(error) || i === providers.length - 1) {
          break;
        }
        
        // Ø§Ù†ØªÙ‚Ù„ Ù„Ù„Ù…Ø²ÙˆØ¯ Ø§Ù„ØªØ§Ù„ÙŠ
        console.log(`ğŸ”„ Falling back to next provider...`);
      }
    }

    throw new Error(`All providers failed. Last error: ${lastError?.message}`);
  }

  /**
   * ØªÙ†ÙÙŠØ° Ù…Ø¹ Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ù†ÙØ³ Ø§Ù„Ù…Ø²ÙˆØ¯
   */
  private async executeWithRetry(
    provider: IAIProvider,
    operation: (provider: IAIProvider) => Promise<UnifiedResponse>,
    attempt: number
  ): Promise<UnifiedResponse> {
    try {
      return await operation(provider);
    } catch (error: any) {
      // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø© Ø£Ùˆ Ø§Ù„Ø®Ø·Ø£ ØºÙŠØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø¥Ø¹Ø§Ø¯Ø©ØŒ Ø§Ø±Ù…Ù Ø§Ù„Ø®Ø·Ø£
      if (attempt >= this.maxRetries || !this.isRetryableError(error)) {
        throw error;
      }
      
      // Ø§Ù†ØªØ¸Ø± Ø«Ù… Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
      const delay = this.calculateRetryDelay(attempt);
      console.log(`â³ Retry attempt ${attempt} after ${delay}ms...`);
      await this.sleep(delay);
      
      return this.executeWithRetry(provider, operation, attempt + 1);
    }
  }

  /**
   * ØªØ±ØªÙŠØ¨ Fallback Ø§Ù„Ø°ÙƒÙŠ
   */
  private getFallbackOrder(primaryProvider: string, context: any): string[] {
    const allProviders = this.registry.getAvailableProviders();
    const otherProviders = allProviders.filter(p => p !== primaryProvider);
    
    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ù‡Ù…Ø© ØªØ­ØªØ§Ø¬ Ø£Ø¯ÙˆØ§ØªØŒ Ù†ÙØ¶Ù„ Ø§Ù„Ù…Ø²ÙˆØ¯ÙŠÙ† Ø§Ù„Ø°ÙŠÙ† ÙŠØ¯Ø¹Ù…ÙˆÙ†Ù‡Ø§
    if (context.requiresTools) {
      const providersWithTools = otherProviders.filter(provider => {
        const capabilities = this.registry.getProvider(provider).getCapabilities();
        return capabilities.supportsTools;
      });
      
      const providersWithoutTools = otherProviders.filter(provider => 
        !providersWithTools.includes(provider)
      );
      
      return [primaryProvider, ...providersWithTools, ...providersWithoutTools];
    }
    
    // ØªØ±ØªÙŠØ¨ Ø¹Ø§Ø¯ÙŠ
    return [primaryProvider, ...otherProviders];
  }

  /**
   * Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø®Ø·Ø£ Ù‚Ø§Ø¨Ù„Ø§Ù‹ Ù„Ù„Ø¥Ø¹Ø§Ø¯Ø©
   */
  private isRetryableError(error: any): boolean {
    const errorMessage = error.message.toLowerCase();
    return this.retryableErrors.some(retryableError => 
      errorMessage.includes(retryableError)
    );
  }

  /**
   * Ø­Ø³Ø§Ø¨ ÙˆÙ‚Øª Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„Ù„Ø¥Ø¹Ø§Ø¯Ø©
   */
  private calculateRetryDelay(attempt: number): number {
    // Exponential backoff: 1s, 2s, 4s, ...
    return Math.min(1000 * Math.pow(2, attempt - 1), 10000);
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Fallback
   */
  getTotalRequests(): number {
    // Ø³ÙŠØªÙ… ØªÙ†ÙÙŠØ° Ù‡Ø°Ø§ Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©
    return 0;
  }

  getSuccessRate(): number {
    // Ø³ÙŠØªÙ… ØªÙ†ÙÙŠØ° Ù‡Ø°Ø§ Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø±Ø§Ù‚Ø¨Ø©
    return 1;
  }
}
4. Ø§Ù„ØªÙƒØ§Ù…Ù„ Ù…Ø¹ Agent Loop Ø§Ù„Ø­Ø§Ù„ÙŠ
integration/agent-loop-integration.ts

typescript
import { IntelligentRouter } from '../router/intelligent-router';
import { ProviderRegistry } from '../registry/provider-registry';
import { UnifiedMessage, UnifiedTool } from '../interfaces';

/**
 * ØªÙƒØ§Ù…Ù„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ Agent Loop Ø§Ù„Ø­Ø§Ù„ÙŠ
 */
export class AgentLoopIntegration {
  private router: IntelligentRouter;

  constructor(router: IntelligentRouter) {
    this.router = router;
  }

  /**
   * Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„Ù€ Agent Loop
   */
  async executeAgentLoop(
    messages: any[], // Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¨Ø§Ù„ØµÙŠØºØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
    tools: any[] = [], // Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø¨Ø§Ù„ØµÙŠØºØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
    options: any = {}
  ): Promise<any> {
    try {
      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù„Ù„ØµÙŠØºØ© Ø§Ù„Ù…ÙˆØ­Ø¯Ø©
      const unifiedMessages = this.convertToUnifiedMessages(messages);
      const unifiedTools = this.convertToUnifiedTools(tools);

      let response;
      
      if (unifiedTools.length > 0) {
        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ØªØ§Ø­Ø©
        response = await this.router.chatWithTools(unifiedMessages, unifiedTools, {
          providerPreference: options.provider,
          budget: options.budget,
          speedPriority: options.speedPriority
        });
      } else {
        // Ù…Ø­Ø§Ø¯Ø«Ø© Ø¹Ø§Ø¯ÙŠØ©
        response = await this.router.chat(unifiedMessages, {
          providerPreference: options.provider,
          budget: options.budget,
          speedPriority: options.speedPriority
        });
      }

      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù„Ù„ØµÙŠØºØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
      return this.convertFromUnifiedResponse(response);
      
    } catch (error) {
      console.error('Agent Loop Integration Error:', error);
      throw error;
    }
  }

  /**
   * ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„ØµÙŠØºØ© Ø§Ù„Ù…ÙˆØ­Ø¯Ø©
   */
  private convertToUnifiedMessages(messages: any[]): UnifiedMessage[] {
    return messages.map(msg => ({
      role: this.mapRole(msg.role),
      content: msg.content,
      metadata: {
        agentType: msg.agentType,
        timestamp: msg.timestamp,
        ...(msg.metadata || {})
      }
    }));
  }

  /**
   * ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„ØµÙŠØºØ© Ø§Ù„Ù…ÙˆØ­Ø¯Ø©
   */
  private convertToUnifiedTools(tools: any[]): UnifiedTool[] {
    return tools.map(tool => ({
      name: tool.name,
      description: tool.description,
      parameters: tool.parameters || {},
      execute: tool.execute || (() => Promise.resolve({}))
    }));
  }

  /**
   * ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù…ÙˆØ­Ø¯Ø© Ù„Ù„ØµÙŠØºØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
   */
  private convertFromUnifiedResponse(response: any): any {
    return {
      content: response.content,
      tool_calls: response.toolCalls,
      metadata: {
        provider: response.metadata.provider,
        model: response.metadata.model,
        cost: response.metadata.cost,
        tokens: response.metadata.tokens,
        duration: response.metadata.duration,
        ...response.metadata
      }
    };
  }

  /**
   * ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø¯ÙˆØ§Ø± Ø¨ÙŠÙ† Ø§Ù„ØµÙŠØº Ø§Ù„Ù…Ø®ØªÙ„ÙØ©
   */
  private mapRole(role: string): 'system' | 'user' | 'assistant' {
    const roleMap: Record<string, 'system' | 'user' | 'assistant'> = {
      'system': 'system',
      'user': 'user', 
      'assistant': 'assistant',
      'ai': 'assistant',
      'human': 'user'
    };
    
    return roleMap[role] || 'user';
  }

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù… Ù„Ù„Øª debugging
   */
  getIntegrationStats(): any {
    return this.router.getRouterStats();
  }
}
5. Ø§Ù„ØªÙƒØ§Ù…Ù„ Ù…Ø¹ CLI
integration/cli-integration.ts

typescript
import { IntelligentRouter } from '../router/intelligent-router';
import { ProviderRegistry } from '../registry/provider-registry';
import { createDefaultProviderRegistry } from '../index';

/**
 * ØªÙƒØ§Ù…Ù„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ CLI Ø§Ù„Ø­Ø§Ù„ÙŠ
 */
export class CLIIntegration {
  private router: IntelligentRouter;
  private registry: ProviderRegistry;

  constructor() {
    this.registry = createDefaultProviderRegistry();
    this.router = new IntelligentRouter(this.registry);
  }

  /**
   * ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯ ÙÙŠ CLI
   */
  initialize(): void {
    console.log('ğŸš€ Initializing Unified Provider System...');
    
    const availableProviders = this.registry.getAvailableProviders();
    console.log(`âœ… Available providers: ${availableProviders.join(', ')}`);
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø²ÙˆØ¯ÙŠÙ†
    this.validateProviders().then(validations => {
      console.log('ğŸ” Provider validations:');
      Object.entries(validations).forEach(([provider, isValid]) => {
        console.log(`   ${provider}: ${isValid ? 'âœ…' : 'âŒ'}`);
      });
    });
  }

  /**
   * Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø¯Ø§Ù„Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© ÙÙŠ CLI
   */
  async handleChatCommand(
    userInput: string, 
    conversationHistory: any[] = [],
    options: any = {}
  ): Promise<any> {
    const messages = this.buildMessages(userInput, conversationHistory);
    
    try {
      const response = await this.router.chat(messages, {
        providerPreference: options.provider,
        budget: options.budget,
        speedPriority: options.speedPriority
      });

      // ØªØ­Ø¯ÙŠØ« Ø³Ø¬Ù„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
      const newConversation = [
        ...conversationHistory,
        { role: 'user', content: userInput },
        { role: 'assistant', content: response.content }
      ];

      return {
        response: response.content,
        conversation: newConversation,
        metadata: response.metadata
      };
      
    } catch (error) {
      console.error('âŒ Chat command failed:', error);
      throw error;
    }
  }

  /**
   * Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù…Ù† Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ÙˆØ³Ø¬Ù„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
   */
  private buildMessages(userInput: string, conversationHistory: any[]): any[] {
    const messages = [];
    
    // Ø¥Ø¶Ø§ÙØ© Ø³Ø¬Ù„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚
    conversationHistory.forEach(msg => {
      messages.push({
        role: msg.role,
        content: msg.content
      });
    });
    
    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¯Ø®Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯
    messages.push({
      role: 'user',
      content: userInput
    });
    
    return messages;
  }

  /**
   * Ø£Ù…Ø± Ø¬Ø¯ÙŠØ¯ Ù„ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø²ÙˆØ¯ ÙŠØ¯ÙˆÙŠØ§Ù‹
   */
  async switchProvider(providerName: string): Promise<boolean> {
    try {
      const provider = this.registry.getProvider(providerName);
      const isValid = await provider.validate();
      
      if (isValid) {
        console.log(`âœ… Switched to provider: ${providerName}`);
        return true;
      } else {
        console.log(`âŒ Provider ${providerName} is not valid`);
        return false;
      }
    } catch (error) {
      console.log(`âŒ Failed to switch to provider: ${providerName}`);
      return false;
    }
  }

  /**
   * Ø¹Ø±Ø¶ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…
   */
  showStats(): any {
    return this.router.getRouterStats();
  }

  /**
   * Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø²ÙˆØ¯ÙŠÙ†
   */
  private async validateProviders(): Promise<Record<string, boolean>> {
    return this.registry.validateAllProviders();
  }
}
ğŸ”§ Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ù„Ù„Ù†Ø¸Ø§Ù…
ØªØ­Ø¯ÙŠØ« index.ts Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ:

typescript
// ... Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø³Ø§Ø¨Ù‚ ...

// ØªØµØ¯ÙŠØ± Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
export { IntelligentRouter } from './router/intelligent-router';
export { ProviderSelector } from './router/provider-selector';
export { FallbackManager } from './router/fallback-manager';
export { AgentLoopIntegration } from './integration/agent-loop-integration';
export { CLIIntegration } from './integration/cli-integration';

// Ø¯Ø§Ù„Ø© Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©
export function createCompleteAISystem(): {
  router: IntelligentRouter;
  integration: AgentLoopIntegration;
  cli: CLIIntegration;
} {
  const registry = createDefaultProviderRegistry();
  const router = new IntelligentRouter(registry);
  const integration = new AgentLoopIntegration(router);
  const cli = new CLIIntegration();

  return { router, integration, cli };
}

// Ø¯Ø§Ù„Ø© Ø³Ø±ÙŠØ¹Ø© Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
export const aiSystem = createCompleteAISystem();
